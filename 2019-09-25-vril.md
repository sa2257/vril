+++
title = "Vril! Vector Bril"
extra.author = "Helena Caminal, Sachille Atapattu and Tuan Ta"
extra.author_link = ""
extra.bio = """
"""
+++

Why Vectors are cool to have!
---------------------------

## High-level idea
In principle vectors are just one-dimensional arrays. An array is a collection of elements that can be accessed by index. However, there are lot of applications where you would perform the same operation on each and every element of an array. These can be performed in hardware by accessing each element one after the other, which is known as scalar, or hardware itself can support simultaneuous access to each element in the array, which is a vector operation.

Vector architectures aim at a tradeoff of using additional resources to run multiple elements in parallel with little impact on the control logic, at the cost of being dependent on the workloads to contain sufficient data-level parallelism to achieve full utilization.

Traditionally, vector architectures used
- programmer support
- auto-vectorization
- microarchitectural optimizations
to expose vector operands in the computation.
Programmer lead vectorization allows explicit control, but usually becomes architecture specific and assumes vector-like programming from the programmer.

Auto-vectorization aims to avoid those issues and do a compiler pass to automatically format vectors in a given program. However, in practice this has been done by programmer specified pragmas to ease the burden for the compiler.

Microarchitectural optimizations have a hardware overhead, but are more programmer friendly as vectorization is done at runtime on a generic program.

Another approach is decoupling the program specification and underlying execution which is architecture-specific. The programmer could define vectors and do operations on them. Microarchitecture will take this general specification and schedule operations to match available data-parallelism. Existing vector ISAs provide a contract between the compiler and the microarchitecture for this decoupling.

This project is aiming at having these general vector specifications at the compiler-level which
- permits vector programming languages to easily generate a bril IR
- permits architecture specific backend to easily generate an executable
- naturally expose opportunities for vector optimizations at bril

## Differentiate and compare realistically with Dietrich's and Phil's.

## Implementation peculiarities that might be interesting at the intro

## Link to project

Arrays
------------------

## Array extension in ISA
Definition of an array in Vril is a sequence of elements of any type (no type checking carried out) and the length being any Bril literal. 

## Adding arrays to bril
Vril extends the grammar of Bril to include arrays by adding an `init` operator to initialize an array of length `l` as follows,
```
array_name : array = init l
```

Vril adds array operations to Bril of the form,
```
array/ variable: type = aop args
```
## Supported array operations
`a2v`
`v2a`

To put a constant into an array, the constant should first be put to a variable.
To operate with a scalar operator (for instance `print`) on a single element, the array element has to first be put to a variable.

## Adding them in the interpreter

Vector ops
----------------------------

## Vector ops in ISA
Vector oprations in Vril are a subset of array operations. So the grammar does not require to be extended further.

## Adding vector ops to Bril
`vadd`
`setvl`

## Simulating vector ops in Brili

Evaluation
----------------------------

## Claim

## Comparison

## Benchmark

## Data Analysis

## Metrics

## Experimental Design

## Presentation

## Conclusion: Why we think its cool!


[cs6120]: @/_index.md
